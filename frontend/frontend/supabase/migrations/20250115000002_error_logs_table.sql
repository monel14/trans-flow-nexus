-- Création de la table error_logs pour les journaux d'erreurs système
-- Table dédiée séparée de app_audit_log pour une meilleure séparation des responsabilités

CREATE TABLE public.error_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    timestamp TIMESTAMPTZ DEFAULT now() NOT NULL,
    level TEXT NOT NULL CHECK (level IN ('error', 'warning', 'info', 'debug', 'critical')),
    source TEXT NOT NULL CHECK (source IN ('api', 'database', 'frontend', 'system', 'external')),
    message TEXT NOT NULL,
    stack_trace TEXT,
    context JSONB DEFAULT '{}'::jsonb,
    user_id TEXT,
    user_name TEXT,
    request_url TEXT,
    request_method TEXT,
    response_status INTEGER,
    session_id TEXT,
    ip_address INET,
    user_agent TEXT,
    resolved BOOLEAN DEFAULT FALSE,
    resolved_at TIMESTAMPTZ,
    resolved_by TEXT,
    resolution_notes TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    
    -- Contraintes de validation
    CONSTRAINT valid_response_status CHECK (response_status >= 100 AND response_status <= 599),
    CONSTRAINT valid_request_method CHECK (request_method IN ('GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'))
);

-- Index pour améliorer les performances des requêtes fréquentes
CREATE INDEX idx_error_logs_timestamp ON public.error_logs (timestamp DESC);
CREATE INDEX idx_error_logs_level ON public.error_logs (level);
CREATE INDEX idx_error_logs_source ON public.error_logs (source);
CREATE INDEX idx_error_logs_user_id ON public.error_logs (user_id);
CREATE INDEX idx_error_logs_resolved ON public.error_logs (resolved);
CREATE INDEX idx_error_logs_created_at_level ON public.error_logs (created_at DESC, level);

-- Index composé pour les requêtes avec filtres multiples
CREATE INDEX idx_error_logs_composite ON public.error_logs (level, source, timestamp DESC);

-- Index GIN pour les recherches dans le contexte JSON
CREATE INDEX idx_error_logs_context_gin ON public.error_logs USING GIN (context);

-- Fonction pour nettoyer automatiquement les anciens logs (optionnel)
CREATE OR REPLACE FUNCTION cleanup_old_error_logs()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Supprimer les logs de plus de 90 jours (sauf les erreurs critiques)
    DELETE FROM public.error_logs 
    WHERE created_at < (now() - INTERVAL '90 days')
    AND level != 'critical';
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- RLS (Row Level Security)
ALTER TABLE public.error_logs ENABLE ROW LEVEL SECURITY;

-- Politique de lecture : Développeurs et admins peuvent lire tous les logs
CREATE POLICY "error_logs_read_policy" ON public.error_logs
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles p
            JOIN public.roles r ON p.role_id = r.id
            WHERE p.id = auth.uid()
            AND r.name IN ('developer', 'admin_general', 'sous_admin')
        )
    );

-- Politique d'écriture : Tous les utilisateurs authentifiés peuvent créer des logs
CREATE POLICY "error_logs_insert_policy" ON public.error_logs
    FOR INSERT
    WITH CHECK (auth.uid() IS NOT NULL);

-- Politique de mise à jour : Seuls les développeurs peuvent marquer comme résolu
CREATE POLICY "error_logs_update_policy" ON public.error_logs
    FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles p
            JOIN public.roles r ON p.role_id = r.id
            WHERE p.id = auth.uid()
            AND r.name = 'developer'
        )
    );

-- Politique de suppression : Seuls les développeurs peuvent supprimer
CREATE POLICY "error_logs_delete_policy" ON public.error_logs
    FOR DELETE
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles p
            JOIN public.roles r ON p.role_id = r.id
            WHERE p.id = auth.uid()
            AND r.name = 'developer'
        )
    );

-- Fonction helper pour créer un log d'erreur
CREATE OR REPLACE FUNCTION log_error(
    p_level TEXT,
    p_source TEXT,
    p_message TEXT,
    p_stack_trace TEXT DEFAULT NULL,
    p_context JSONB DEFAULT '{}'::jsonb,
    p_request_url TEXT DEFAULT NULL,
    p_request_method TEXT DEFAULT NULL,
    p_response_status INTEGER DEFAULT NULL
)
RETURNS BIGINT AS $$
DECLARE
    log_id BIGINT;
    current_user_id TEXT;
    current_user_name TEXT;
BEGIN
    -- Récupérer les informations de l'utilisateur actuel
    current_user_id := auth.uid()::TEXT;
    
    IF current_user_id IS NOT NULL THEN
        SELECT name INTO current_user_name 
        FROM public.profiles 
        WHERE id = current_user_id;
    END IF;
    
    -- Insérer le log d'erreur
    INSERT INTO public.error_logs (
        level,
        source,
        message,
        stack_trace,
        context,
        user_id,
        user_name,
        request_url,
        request_method,
        response_status
    ) VALUES (
        p_level,
        p_source,
        p_message,
        p_stack_trace,
        p_context,
        current_user_id,
        current_user_name,
        p_request_url,
        p_request_method,
        p_response_status
    ) RETURNING id INTO log_id;
    
    RETURN log_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Commentaires pour la documentation
COMMENT ON TABLE public.error_logs IS 'Table dédiée aux journaux d''erreurs système, séparée des audits';
COMMENT ON COLUMN public.error_logs.level IS 'Niveau de sévérité: error, warning, info, debug, critical';
COMMENT ON COLUMN public.error_logs.source IS 'Source de l''erreur: api, database, frontend, system, external';
COMMENT ON COLUMN public.error_logs.context IS 'Contexte JSON avec détails additionnels';
COMMENT ON COLUMN public.error_logs.resolved IS 'Indique si l''erreur a été résolue';
COMMENT ON FUNCTION log_error IS 'Fonction helper pour créer facilement un log d''erreur';
COMMENT ON FUNCTION cleanup_old_error_logs IS 'Fonction pour nettoyer les anciens logs (à exécuter périodiquement)';